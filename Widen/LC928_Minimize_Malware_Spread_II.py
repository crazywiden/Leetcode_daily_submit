"""
928. Minimize Malware Spread II
(This problem is the same as Minimize Malware Spread, with the differences bolded.)

In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1.

Some nodes initial are initially infected by malware.  Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.  This spread of malware will continue until no more nodes can be infected in this manner.

Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops.

We will remove one node from the initial list, completely removing it and any connections from this node to any other node.  Return the node that if removed, would minimize M(initial).  If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.

 

Example 1:

Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
Output: 0
Example 2:

Input: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]
Output: 1
Example 3:

Input: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]
Output: 1
"""

# dfs version
# time complexity -- O()
class Solution:
    def minMalwareSpread(self, G: List[List[int]], initial: List[int]) -> int:
        N = len(G)
        initial = set(initial)
        # key is the node, value is the set of initial node to which it connects
        self.connections = collections.defaultdict(list)
        graph = collections.defaultdict(set)
        for i in range(N):
            for j in range(N):
                if G[i][j] == 0:
                    continue
                graph[i].add(j)
                graph[j].add(i)
                
        for root in initial:
            visited = set([root])
            for child in graph[root]:
                if child in initial:
                    continue
                self.dfs(root, graph, visited, child, initial)
            
        # print(self.connections)
        res = {ele:0 for ele in initial}
        for key, val in self.connections.items():
            if len(val) != 1:
                continue
            res[val[0]] += 1
        max_res = max(res.values())
        for key in sorted(res.keys()):
            if res[key] == max_res:
                return key
            
    def dfs(self, root, graph, visited, ele, initial):
        if ele not in graph:
            return 
        visited.add(ele)
        self.connections[ele].append(root)
        for child in graph[ele]:
            if child in initial:
                continue
            if child in visited:
                continue
            self.dfs(root, graph, visited, child, initial)
            
                                  
    
    
    
# dfs version
# took too long to finish
# should be more famliar with this
# Runtime: 1048 ms, faster than 84.40% of Python3 online submissions for Minimize Malware Spread II.
# Memory Usage: 16.4 MB, less than 50.00% of Python3 online submissions for Minimize Malware Spread II.
class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        dict_graph = collections.defaultdict(set)
        initial = sorted(initial)
        n = len(graph)
        for i in range(n):
            for j in range(i+1, n):
                if graph[i][j] != 1:
                    continue
                dict_graph[i].add(j)
                dict_graph[j].add(i)
        infected = float("inf")
        res = -1
        for node in initial:
            # num_malware = self.cal_malware(dict_graph, initial, set([node]))
            self.visited = set([node])
            num_malware = 0
            for new_node in initial:
                if new_node in self.visited:
                    continue
                self.visited.add(new_node)
                num_malware += self.dfs(dict_graph, new_node, 1)
            if num_malware < infected:
                res = node
                infected = num_malware
        return res

    def dfs(self, graph, node, cnt):
        for nei in graph[node]:
            if nei in self.visited:
                continue
            self.visited.add(nei)
            cnt += self.dfs(graph, nei, 1)
        return cnt
        
    def cal_malware(self, graph, initial, visited):
        # bfs to find number of malware
        deque = [val for val in initial if val not in visited]
        num_malware = 0
        for node in deque:
            visited.add(node)
        while deque:
            node = deque.pop(0)
            for nei in graph[node]:
                if nei in visited:
                    continue
                visited.add(nei)
                num_malware += 1
                deque.append(nei)
        return num_malware
                
                
            
        
# just brutal force bfs
# time complextiy -- O(n^2 + k*n)
# Runtime: 1020 ms, faster than 91.74% of Python3 online submissions for Minimize Malware Spread II.
# Memory Usage: 16.4 MB, less than 50.00% of Python3 online submissions for Minimize Malware Spread II.
class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        dict_graph = collections.defaultdict(set)
        initial = sorted(initial)
        n = len(graph)
        for i in range(n):
            for j in range(i+1, n):
                if graph[i][j] != 1:
                    continue
                dict_graph[i].add(j)
                dict_graph[j].add(i)
        infected = float("inf")
        res = -1
        for node in initial:
            num_malware = self.cal_malware(dict_graph, initial, set([node]))
            if num_malware < infected:
                res = node
                infected = num_malware
        return res

    def cal_malware(self, graph, initial, visited):
        deque = [val for val in initial if val not in visited]
        num_malware = 0
        for node in deque:
            visited.add(node)
        while deque:
            node = deque.pop(0)
            for nei in graph[node]:
                if nei in visited:
                    continue
                visited.add(nei)
                num_malware += 1
                deque.append(nei)
        return num_malware
                
                
            
        
